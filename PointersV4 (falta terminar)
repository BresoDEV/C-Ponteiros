#include <iostream>
#include <windows.h>
#include <iostream>
#include <vector>
#include <conio.h> 
#include <TlHelp32.h>
#include <stdio.h> 
#include <tchar.h> 
#include <iostream>
#include <windows.h>
#include <iostream>
#include <vector>
#include <conio.h> 
#include <TlHelp32.h>
#include <stdio.h> 
#include <tchar.h> 

using namespace std;



using namespace std;


namespace Configuracoes_Jogo
{
	LPCWSTR Jogo = TEXT("Gameface");			//Nome da janela do jogo
	LPCWSTR Jogo_exe = TEXT("SanAndreas.exe");		//Nome do executavel do jogo .exe
}


namespace FuncoesUteis
{
	DWORD ID_Processo() // Funcionando
	{
		PROCESSENTRY32 pt;
		HANDLE hsnap = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
		pt.dwSize = sizeof(PROCESSENTRY32);
		if (Process32First(hsnap, &pt)) {  
			do {
				if (!lstrcmpi(pt.szExeFile, Configuracoes_Jogo::Jogo_exe)) {
					CloseHandle(hsnap);
					return pt.th32ProcessID;
				}
			} while (Process32Next(hsnap, &pt));
		}
		CloseHandle(hsnap);  
		return 0;
	}

	bool Check_JogoAberto()//Funcionando
	{
		HWND hWnd = FindWindow(0, Configuracoes_Jogo::Jogo);
		DWORD pId = ID_Processo();
		HANDLE process = OpenProcess(SYNCHRONIZE, FALSE, pId);
		DWORD ret = WaitForSingleObject(process, 0);
		CloseHandle(process);
		return ret == WAIT_TIMEOUT;
	}

	uintptr_t GetModuleBaseAddress(DWORD procId, const TCHAR* modName)//Funcionando
	{
		uintptr_t modBaseAddr = 0;
		HANDLE hSnap = CreateToolhelp32Snapshot(TH32CS_SNAPMODULE | TH32CS_SNAPMODULE32, procId);
		if (hSnap != INVALID_HANDLE_VALUE)
		{
			MODULEENTRY32 modEntry;
			modEntry.dwSize = sizeof(modEntry);
			if (Module32First(hSnap, &modEntry))
			{
				do
				{
					if (!lstrcmpi(modEntry.szModule, modName))
					{
						modBaseAddr = (uintptr_t)modEntry.modBaseAddr;
						break;
					}
				} while (Module32Next(hSnap, &modEntry));
			}
		}
		CloseHandle(hSnap);
		return modBaseAddr;


	}

	void SobrescreverMemoria(DWORD Offset, int valor)//Funcionando LINDAMENTEEEEE
	{
		DWORD pId = FuncoesUteis::ID_Processo();
		HWND hWnd = FindWindow(0, Configuracoes_Jogo::Jogo);
		HANDLE hProc = OpenProcess(PROCESS_ALL_ACCESS, FALSE, pId); 
		WriteProcessMemory(hProc, (void*)0x7FF656F6F0D8, &valor, sizeof(valor), nullptr);
	}

}


//Pronto
namespace Int
{
	namespace Com_Modulo
	{
		void Escrever(DWORD Offset, int valor)
		{
			/*Exemplo:
			Quando for globais, exemplo GTAV.exe+524F0D8
			Usa-se o valor dps da adicao
			Int::Com_Modulo::Escrever(0x524F0D8, 30);

			*/
			HWND hWnd = FindWindow(0, Configuracoes_Jogo::Jogo);
			DWORD pId;
			GetWindowThreadProcessId(hWnd, &pId);
			HANDLE hProc = OpenProcess(PROCESS_ALL_ACCESS, FALSE, pId);
			DWORD Modulo_Base_Jogo = FuncoesUteis::GetModuleBaseAddress(pId, Configuracoes_Jogo::Jogo_exe);
			DWORD base = Modulo_Base_Jogo + Offset;
			//return WriteProcessMemory(hProc, (void*)base, &valor, sizeof(valor), nullptr);
			FuncoesUteis::SobrescreverMemoria(base, valor);
		}

		int Ler(DWORD offset)
		{
			/*Exemplo:
			Quando for globais, exemplo GTAV.exe+524F0D8
			Usa-se o valor dps da adicao
			cout << Int::Com_Modulo::Ler(0x524F0D8);

			*/
			 
			uintptr_t mod = FuncoesUteis::GetModuleBaseAddress(FuncoesUteis::ID_Processo(), Configuracoes_Jogo::Jogo_exe);
			mod += offset;
			HANDLE wesnoth_process = OpenProcess(PROCESS_ALL_ACCESS, true, FuncoesUteis::ID_Processo());
			DWORD gold_value = 0;
			DWORD bytes_read = 0;
			ReadProcessMemory(wesnoth_process, (void*)mod, &gold_value, 4, nullptr);
			return gold_value;

		}
	}

	namespace Fixos
	{
		void Escrever(DWORD Offset, int valor)
		{
			/*
			Usado quando é uma memoria qualquer 
			 Int::Fixos::Escrever(0x7FF656F6F0D8, 86);
			 
			 */
			HWND hWnd = FindWindow(0, Configuracoes_Jogo::Jogo);
			DWORD pId;
			GetWindowThreadProcessId(hWnd, &pId);
			HANDLE hProc = OpenProcess(PROCESS_ALL_ACCESS, FALSE, pId); 
			//return WriteProcessMemory(hProc, (void*)base, &valor, sizeof(valor), nullptr);
			FuncoesUteis::SobrescreverMemoria(Offset, valor);
		}

		int Ler(long long offset)
		{  
			/*
			Usado quando é uma memoria qualquer
			 cout << Int::Fixos::Ler(0x7FF656F6F0D8);

			 */
			long long address = offset; // This is the address that we want to read from
			HANDLE wesnoth_process = OpenProcess(PROCESS_ALL_ACCESS, true, FuncoesUteis::ID_Processo());
			DWORD gold_value = 0;
			ReadProcessMemory(wesnoth_process, (void*)address, &gold_value, 4, nullptr);
			return gold_value;
		}
	}

}

 
 

int main()
{
 
	 Int::Fixos::Escrever(0x7FF656F6F0D8, 86);
}

 
namespace Ponteiros
{
	DWORD Jump_Ponteiro(DWORD EnderecoAdicional, DWORD ponteiro1 = NULL,
		DWORD ponteiro2 = NULL, DWORD ponteiro3 = NULL, DWORD ponteiro4 = NULL,
		DWORD ponteiro5 = NULL, DWORD ponteiro6 = NULL, DWORD ponteiro7 = NULL,
		DWORD ponteiro8 = NULL, DWORD ponteiro9 = NULL, DWORD ponteiro10 = NULL)
	{
		DWORD pId;
		HWND hWnd = FindWindow(0, Configuracoes_Jogo::Jogo);
		GetWindowThreadProcessId(hWnd, &pId);
		HANDLE hProc = OpenProcess(PROCESS_ALL_ACCESS, FALSE, pId);
		DWORD Modulo_Base_Jogo = FuncoesUteis::GetModuleBaseAddress(pId, Configuracoes_Jogo::Jogo_exe);
		DWORD base = Modulo_Base_Jogo + EnderecoAdicional;
		DWORD address = 0;
		DWORD EnderecoFinal = base;
		if (ponteiro1 != NULL)
		{
			ReadProcessMemory(hProc, (void*)EnderecoFinal, &address, sizeof(address), nullptr);
			address += ponteiro1;
			EnderecoFinal = address;
		}
		if (ponteiro2 != NULL)
		{
			address = 0;
			ReadProcessMemory(hProc, (void*)EnderecoFinal, &address, sizeof(address), nullptr);
			address += ponteiro2;
			EnderecoFinal = address;
		}
		if (ponteiro3 != NULL)
		{
			address = 0;
			ReadProcessMemory(hProc, (void*)EnderecoFinal, &address, sizeof(address), nullptr);
			address += ponteiro3;
			EnderecoFinal = address;
		}
		if (ponteiro4 != NULL)
		{
			address = 0;
			ReadProcessMemory(hProc, (void*)EnderecoFinal, &address, sizeof(address), nullptr);
			address += ponteiro4;
			EnderecoFinal = address;
		}
		if (ponteiro5 != NULL)
		{
			address = 0;
			ReadProcessMemory(hProc, (void*)EnderecoFinal, &address, sizeof(address), nullptr);
			address += ponteiro5;
			EnderecoFinal = address;
		}
		if (ponteiro6 != NULL)
		{
			address = 0;
			ReadProcessMemory(hProc, (void*)EnderecoFinal, &address, sizeof(address), nullptr);
			address += ponteiro6;
			EnderecoFinal = address;
		}
		if (ponteiro7 != NULL)
		{
			address = 0;
			ReadProcessMemory(hProc, (void*)EnderecoFinal, &address, sizeof(address), nullptr);
			address += ponteiro7;
			EnderecoFinal = address;
		}
		if (ponteiro8 != NULL)
		{
			address = 0;
			ReadProcessMemory(hProc, (void*)EnderecoFinal, &address, sizeof(address), nullptr);
			address += ponteiro8;
			EnderecoFinal = address;
		}
		if (ponteiro9 != NULL)
		{
			address = 0;
			ReadProcessMemory(hProc, (void*)EnderecoFinal, &address, sizeof(address), nullptr);
			address += ponteiro9;
			EnderecoFinal = address;
		}
		if (ponteiro10 != NULL)
		{
			address = 0;
			ReadProcessMemory(hProc, (void*)EnderecoFinal, &address, sizeof(address), nullptr);
			address += ponteiro10;
			EnderecoFinal = address;
		}
		return EnderecoFinal;
	}
}



//Pronto
namespace String
{

	namespace Com_Modulo
	{

		bool Escrever(DWORD Offset, string valor)
		{
			DWORD pId;
			HWND hWnd = FindWindow(0, Configuracoes_Jogo::Jogo);
			GetWindowThreadProcessId(hWnd, &pId);
			HANDLE hProc = OpenProcess(PROCESS_ALL_ACCESS, FALSE, pId);
			DWORD Modulo_Base_Jogo = FuncoesUteis::GetModuleBaseAddress(pId, Configuracoes_Jogo::Jogo_exe);
			Modulo_Base_Jogo += Offset;
			return WriteProcessMemory(hProc, (void*)Modulo_Base_Jogo, valor.c_str(), sizeof(valor), nullptr); //write
		}

		string Ler(DWORD offset)
		{
			HWND hWnd = FindWindow(0, Configuracoes_Jogo::Jogo);
			DWORD pId;
			GetWindowThreadProcessId(hWnd, &pId);
			HANDLE hProc = OpenProcess(PROCESS_ALL_ACCESS, FALSE, pId);
			DWORD Modulo_Base_Jogo = FuncoesUteis::GetModuleBaseAddress(pId, Configuracoes_Jogo::Jogo_exe);
			Modulo_Base_Jogo += offset;
			string retorno;
			ReadProcessMemory(hProc, (void*)Modulo_Base_Jogo, &retorno, sizeof(retorno), nullptr);
			return retorno.c_str();

		}
	}

	namespace Fixos
	{
		bool Escrever(DWORD Offset, string valor)
		{
			DWORD pId;
			HWND hWnd = FindWindow(0, Configuracoes_Jogo::Jogo);
			GetWindowThreadProcessId(hWnd, &pId);
			HANDLE hProc = OpenProcess(PROCESS_ALL_ACCESS, FALSE, pId);
			return WriteProcessMemory(hProc, (void*)Offset, valor.c_str(), sizeof(valor), nullptr); //write
		}

		string Ler(DWORD offset)
		{
			HWND hWnd = FindWindow(0, Configuracoes_Jogo::Jogo);
			DWORD pId;
			GetWindowThreadProcessId(hWnd, &pId);
			HANDLE hProc = OpenProcess(PROCESS_ALL_ACCESS, FALSE, pId);
			//DWORD Modulo_Base_Jogo = FuncoesUteis::GetModuleBaseAddress(pId, Jogo_exe);
			//Modulo_Base_Jogo += offset;
			string retorno;
			ReadProcessMemory(hProc, (void*)offset, &retorno, sizeof(retorno), nullptr);
			return retorno.c_str();

		}
	}

}

//Pronto
namespace Float
{
	namespace Com_Modulo
	{
		float Ler(DWORD Offset)
		{
			HWND hWnd = FindWindow(0, Configuracoes_Jogo::Jogo);
			DWORD pId;
			GetWindowThreadProcessId(hWnd, &pId);
			HANDLE hProc = OpenProcess(PROCESS_ALL_ACCESS, FALSE, pId);
			DWORD Modulo_Base_Jogo = FuncoesUteis::GetModuleBaseAddress(pId, Configuracoes_Jogo::Jogo_exe);
			Modulo_Base_Jogo += Offset;
			float retorno;
			ReadProcessMemory(hProc, (void*)Modulo_Base_Jogo, &retorno, sizeof(retorno), nullptr);
			return retorno;
		}

		bool Escrever(DWORD Offset, float valor)
		{
			HWND hWnd = FindWindow(0, Configuracoes_Jogo::Jogo);
			DWORD pId;
			GetWindowThreadProcessId(hWnd, &pId);
			HANDLE hProc = OpenProcess(PROCESS_ALL_ACCESS, FALSE, pId);
			DWORD Modulo_Base_Jogo = FuncoesUteis::GetModuleBaseAddress(pId, Configuracoes_Jogo::Jogo_exe);
			DWORD base = Modulo_Base_Jogo + Offset;
			float aa = valor;
			return WriteProcessMemory(hProc, (void*)base, &aa, sizeof(aa), nullptr);
		}
	}

	namespace Fixos
	{
		bool Escrever(DWORD Offset, float valor)
		{
			DWORD pId;
			//HWND hWnd = FindWindow(0, TEXT("Minecraft 1.8.9"));
			HWND hWnd = FindWindow(0, Configuracoes_Jogo::Jogo);
			GetWindowThreadProcessId(hWnd, &pId);
			HANDLE hProc = OpenProcess(PROCESS_ALL_ACCESS, FALSE, pId);
			return WriteProcessMemory(hProc, (void*)Offset, &valor, sizeof(valor), nullptr); //write
		}

		float Ler(DWORD Offset)
		{
			HWND hWnd = FindWindow(0, Configuracoes_Jogo::Jogo);
			DWORD pId;
			GetWindowThreadProcessId(hWnd, &pId);
			HANDLE hProc = OpenProcess(PROCESS_ALL_ACCESS, FALSE, pId);
			//DWORD Modulo_Base_Jogo = FuncoesUteis::GetModuleBaseAddress(pId, Jogo_exe);
			//Modulo_Base_Jogo += Offset;
			float retorno;
			ReadProcessMemory(hProc, (void*)Offset, &retorno, sizeof(retorno), nullptr);
			return retorno;
		}
	}

}
